<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CRUX - Recursive Cognitive AI Demo</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800;900&display=swap');
        @import url('https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;500;600&display=swap');
        
        :root {
            --primary: #2563eb;
            --secondary: #7c3aed;
            --accent: #10b981;
            --warning: #f59e0b;
            --error: #ef4444;
            --bg-dark: #0a0a0f;
            --bg-card: rgba(15, 15, 25, 0.9);
            --text-primary: #ffffff;
            --text-secondary: rgba(255, 255, 255, 0.7);
            --text-muted: rgba(255, 255, 255, 0.5);
            --border: rgba(255, 255, 255, 0.1);
            --shadow: 0 20px 40px rgba(0, 0, 0, 0.3);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', sans-serif;
            background: var(--bg-dark);
            color: var(--text-primary);
            line-height: 1.6;
            overflow-x: hidden;
        }

        .container {
            max-width: 1600px;
            margin: 0 auto;
            padding: 20px;
        }

        .header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 30px 0;
            border-bottom: 1px solid var(--border);
            margin-bottom: 40px;
        }

        .logo {
            font-size: 2rem;
            font-weight: 800;
            background: linear-gradient(135deg, var(--primary), var(--secondary), var(--accent));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .header-controls {
            display: flex;
            gap: 15px;
            align-items: center;
        }

        .btn {
            padding: 12px 24px;
            border-radius: 8px;
            font-weight: 600;
            font-size: 0.9rem;
            text-decoration: none;
            transition: all 0.3s ease;
            cursor: pointer;
            border: none;
            display: inline-flex;
            align-items: center;
            gap: 8px;
        }

        .btn-primary {
            background: linear-gradient(135deg, var(--primary), var(--secondary));
            color: white;
        }

        .btn-secondary {
            background: var(--bg-card);
            color: var(--text-primary);
            border: 1px solid var(--border);
        }

        .btn:hover {
            transform: translateY(-2px);
        }

        .demo-grid {
            display: grid;
            grid-template-columns: 1fr 400px;
            gap: 30px;
            margin-bottom: 40px;
        }

        .main-demo {
            display: flex;
            flex-direction: column;
            gap: 30px;
        }

        .demo-section {
            background: var(--bg-card);
            border: 1px solid var(--border);
            border-radius: 16px;
            overflow: hidden;
            backdrop-filter: blur(20px);
        }

        .section-header {
            padding: 20px 30px;
            border-bottom: 1px solid var(--border);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .section-title {
            font-size: 1.1rem;
            font-weight: 600;
            color: var(--primary);
        }

        .section-status {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 0.85rem;
        }

        .status-indicator {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: var(--accent);
        }

        .status-indicator.processing {
            animation: pulse 1.5s infinite;
            background: var(--warning);
        }

        .status-indicator.improved {
            background: var(--accent);
            animation: glow 2s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.3; }
        }

        @keyframes glow {
            0%, 100% { box-shadow: 0 0 5px var(--accent); }
            50% { box-shadow: 0 0 15px var(--accent), 0 0 25px var(--accent); }
        }

        .input-area {
            padding: 30px;
        }

        .input-field {
            width: 100%;
            min-height: 120px;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid var(--border);
            border-radius: 12px;
            padding: 20px;
            color: var(--text-primary);
            font-family: 'Inter', sans-serif;
            font-size: 0.95rem;
            resize: vertical;
            outline: none;
            transition: border-color 0.3s ease;
        }

        .input-field:focus {
            border-color: var(--primary);
        }

        .input-field::placeholder {
            color: var(--text-muted);
        }

        .example-tasks {
            display: flex;
            gap: 10px;
            margin: 20px 0;
            flex-wrap: wrap;
        }

        .task-btn {
            padding: 8px 16px;
            background: rgba(37, 99, 235, 0.1);
            border: 1px solid rgba(37, 99, 235, 0.3);
            border-radius: 20px;
            color: var(--text-secondary);
            font-size: 0.8rem;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .task-btn:hover {
            background: rgba(37, 99, 235, 0.2);
            transform: translateY(-1px);
        }

        .execute-btn {
            width: 100%;
            padding: 16px;
            background: linear-gradient(135deg, var(--primary), var(--secondary));
            border: none;
            border-radius: 12px;
            color: white;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            margin-top: 20px;
        }

        .execute-btn:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 10px 20px rgba(37, 99, 235, 0.3);
        }

        .execute-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .pipeline-visualization {
            padding: 30px;
            min-height: 600px;
        }

        .cognitive-pipeline {
            display: flex;
            flex-direction: column;
            gap: 25px;
        }

        .mind-step {
            display: flex;
            align-items: center;
            gap: 20px;
            padding: 20px;
            background: rgba(255, 255, 255, 0.02);
            border: 1px solid var(--border);
            border-radius: 12px;
            transition: all 0.5s ease;
            opacity: 0.3;
        }

        .mind-step.active {
            opacity: 1;
            background: rgba(37, 99, 235, 0.1);
            border-color: var(--primary);
            transform: translateX(10px);
            box-shadow: 0 0 20px rgba(37, 99, 235, 0.2);
        }

        .mind-step.completed {
            opacity: 1;
            background: rgba(16, 185, 129, 0.1);
            border-color: var(--accent);
        }

        .mind-step.improved {
            background: rgba(245, 158, 11, 0.1);
            border-color: var(--warning);
            animation: improvement-pulse 2s infinite;
        }

        @keyframes improvement-pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.02); }
        }

        .mind-icon {
            width: 50px;
            height: 50px;
            border-radius: 12px;
            background: linear-gradient(135deg, var(--primary), var(--secondary));
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.3rem;
            color: white;
            flex-shrink: 0;
        }

        .mind-content {
            flex: 1;
        }

        .mind-name {
            font-size: 1rem;
            font-weight: 600;
            margin-bottom: 8px;
        }

        .mind-description {
            font-size: 0.85rem;
            color: var(--text-muted);
            margin-bottom: 12px;
        }

        .mind-output {
            background: rgba(0, 0, 0, 0.4);
            border-radius: 8px;
            padding: 15px;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.8rem;
            line-height: 1.4;
            color: var(--text-secondary);
            white-space: pre-wrap;
            max-height: 150px;
            overflow-y: auto;
            border-left: 3px solid var(--primary);
        }

        .mind-metrics {
            display: flex;
            gap: 15px;
            margin-top: 10px;
        }

        .metric {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 4px;
        }

        .metric-value {
            font-size: 0.9rem;
            font-weight: 600;
            color: var(--accent);
        }

        .metric-label {
            font-size: 0.7rem;
            color: var(--text-muted);
            text-transform: uppercase;
        }

        .sidebar {
            display: flex;
            flex-direction: column;
            gap: 30px;
        }

        .metrics-panel {
            background: var(--bg-card);
            border: 1px solid var(--border);
            border-radius: 16px;
            padding: 25px;
            backdrop-filter: blur(20px);
        }

        .metrics-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-top: 20px;
        }

        .metric-card {
            text-align: center;
            padding: 20px;
            background: rgba(255, 255, 255, 0.02);
            border-radius: 12px;
            border: 1px solid var(--border);
        }

        .metric-card .value {
            font-size: 1.8rem;
            font-weight: 700;
            color: var(--primary);
            margin-bottom: 8px;
        }

        .metric-card .label {
            font-size: 0.8rem;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .improvement-tracker {
            background: var(--bg-card);
            border: 1px solid var(--border);
            border-radius: 16px;
            padding: 25px;
            backdrop-filter: blur(20px);
        }

        .improvement-chart {
            height: 200px;
            margin-top: 20px;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 8px;
            display: flex;
            align-items: end;
            padding: 20px;
            gap: 8px;
        }

        .chart-bar {
            flex: 1;
            background: linear-gradient(to top, var(--primary), var(--accent));
            border-radius: 3px 3px 0 0;
            transition: height 0.5s ease;
            min-height: 20px;
        }

        .performance-log {
            background: var(--bg-card);
            border: 1px solid var(--border);
            border-radius: 16px;
            padding: 25px;
            backdrop-filter: blur(20px);
        }

        .log-entries {
            max-height: 300px;
            overflow-y: auto;
            margin-top: 20px;
        }

        .log-entry {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 8px 0;
            font-size: 0.85rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.05);
        }

        .log-time {
            color: var(--text-muted);
            font-family: 'JetBrains Mono', monospace;
            min-width: 80px;
        }

        .log-type {
            padding: 2px 8px;
            border-radius: 4px;
            font-size: 0.7rem;
            font-weight: 600;
            text-transform: uppercase;
        }

        .log-type.improvement {
            background: rgba(245, 158, 11, 0.2);
            color: var(--warning);
        }

        .log-type.processing {
            background: rgba(37, 99, 235, 0.2);
            color: var(--primary);
        }

        .log-type.complete {
            background: rgba(16, 185, 129, 0.2);
            color: var(--accent);
        }

        .recursive-indicator {
            position: fixed;
            top: 20px;
            right: 20px;
            background: var(--bg-card);
            border: 1px solid var(--border);
            border-radius: 12px;
            padding: 15px 20px;
            backdrop-filter: blur(20px);
            z-index: 100;
            opacity: 0;
            transform: translateY(-20px);
            transition: all 0.3s ease;
        }

        .recursive-indicator.active {
            opacity: 1;
            transform: translateY(0);
        }

        .recursive-text {
            font-size: 0.9rem;
            font-weight: 600;
            color: var(--warning);
        }

        @media (max-width: 1024px) {
            .demo-grid {
                grid-template-columns: 1fr;
                gap: 20px;
            }
            
            .sidebar {
                order: -1;
            }
            
            .metrics-grid {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header class="header">
            <div class="logo">CRUX</div>
            <div class="header-controls">
                <button class="btn btn-secondary" onclick="resetDemo()">Reset Demo</button>
                <button class="btn btn-secondary" onclick="toggleAutoMode()" id="autoBtn">Auto Mode</button>
                <a href="index.html" class="btn btn-primary">← Back to Overview</a>
            </div>
        </header>

        <div class="recursive-indicator" id="recursiveIndicator">
            <div class="recursive-text">🔄 Recursive Self-Improvement Active</div>
        </div>

        <div class="demo-grid">
            <div class="main-demo">
                <!-- Input Section -->
                <div class="demo-section">
                    <div class="section-header">
                        <div class="section-title">Task Input & Execution</div>
                        <div class="section-status">
                            <div class="status-indicator" id="inputStatus"></div>
                            <span id="inputStatusText">Ready</span>
                        </div>
                    </div>
                    <div class="input-area">
                        <textarea 
                            id="taskInput" 
                            class="input-field" 
                            placeholder="Enter a complex task for CRUX to process through its recursive cognitive pipeline..."
                        ></textarea>
                        <div class="example-tasks">
                            <button class="task-btn" onclick="setTask('Develop a comprehensive AI strategy for a Fortune 500 company entering the healthcare market')">AI Strategy</button>
                            <button class="task-btn" onclick="setTask('Design and implement a distributed microservices architecture for handling 10M+ daily transactions')">Architecture Design</button>
                            <button class="task-btn" onclick="setTask('Create a machine learning pipeline for real-time fraud detection with 99.9% accuracy')">ML Pipeline</button>
                            <button class="task-btn" onclick="setTask('Optimize a React application with 50+ components for sub-second load times')">Performance Optimization</button>
                        </div>
                        <button class="execute-btn" id="executeBtn" onclick="startProcessing()">
                            🚀 Execute Recursive Processing
                        </button>
                    </div>
                </div>

                <!-- Cognitive Pipeline Visualization -->
                <div class="demo-section">
                    <div class="section-header">
                        <div class="section-title">Live Cognitive Pipeline</div>
                        <div class="section-status">
                            <div class="status-indicator" id="pipelineStatus"></div>
                            <span id="pipelineStatusText">Idle</span>
                        </div>
                    </div>
                    <div class="pipeline-visualization">
                        <div class="cognitive-pipeline" id="pipeline">
                            <!-- Pipeline steps will be dynamically generated -->
                        </div>
                    </div>
                </div>
            </div>

            <div class="sidebar">
                <!-- Real-time Metrics -->
                <div class="metrics-panel">
                    <div class="section-title">Performance Metrics</div>
                    <div class="metrics-grid">
                        <div class="metric-card">
                            <div class="value" id="processingTime">0ms</div>
                            <div class="label">Processing Time</div>
                        </div>
                        <div class="metric-card">
                            <div class="value" id="improvementCycles">0</div>
                            <div class="label">Improvement Cycles</div>
                        </div>
                        <div class="metric-card">
                            <div class="value" id="efficiencyGain">0%</div>
                            <div class="label">Efficiency Gain</div>
                        </div>
                        <div class="metric-card">
                            <div class="value" id="accuracyScore">0%</div>
                            <div class="label">Accuracy Score</div>
                        </div>
                    </div>
                </div>

                <!-- Recursive Improvement Tracker -->
                <div class="improvement-tracker">
                    <div class="section-title">Self-Improvement Progress</div>
                    <div class="improvement-chart" id="improvementChart">
                        <!-- Chart bars will be dynamically generated -->
                    </div>
                </div>

                <!-- Performance Log -->
                <div class="performance-log">
                    <div class="section-title">System Events</div>
                    <div class="log-entries" id="logEntries">
                        <div class="log-entry">
                            <div class="log-time">00:00</div>
                            <div class="log-type complete">ready</div>
                            <div>CRUX cognitive pipeline initialized</div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Global state
        let isProcessing = false;
        let autoMode = false;
        let improvementCycles = 0;
        let startTime = 0;
        let performanceData = [100];
        let logCounter = 0;

        // Mind definitions with recursive improvement capabilities
        const cognitiveMinds = [
            {
                id: 'input_analysis',
                name: 'Input Analysis',
                icon: '🔍',
                description: 'Analyzes task complexity and domain requirements',
                baseEfficiency: 85,
                process: async (input) => {
                    const complexity = calculateComplexity(input);
                    const domain = detectDomain(input);
                    return {
                        complexity,
                        domain,
                        requirements: extractRequirements(input),
                        processingTime: 200 + Math.random() * 300
                    };
                }
            },
            {
                id: 'reflection',
                name: 'Recursive Reflection',
                icon: '🤔',
                description: 'Self-analyzes and optimizes reasoning patterns',
                baseEfficiency: 80,
                process: async (input, context) => {
                    const reflection = await generateReflection(input, context);
                    const optimizations = identifyOptimizations(context);
                    return {
                        reflection,
                        optimizations,
                        selfImprovements: optimizations.length,
                        processingTime: 300 + Math.random() * 400
                    };
                }
            },
            {
                id: 'planning',
                name: 'Strategic Planning',
                icon: '📋',
                description: 'Creates optimized execution strategies',
                baseEfficiency: 90,
                process: async (input, context) => {
                    const strategy = await generateStrategy(input, context);
                    const optimizedPlan = await optimizePlan(strategy, context);
                    return {
                        strategy: optimizedPlan,
                        steps: optimizedPlan.steps,
                        efficiency: optimizedPlan.efficiency,
                        processingTime: 400 + Math.random() * 500
                    };
                }
            },
            {
                id: 'execution',
                name: 'Adaptive Execution Mind',
                icon: '⚡',
                description: 'Implements solutions with real-time optimization',
                baseEfficiency: 88,
                process: async (input, context) => {
                    const execution = await executeStrategy(input, context);
                    const adaptations = await adaptExecution(execution, context);
                    return {
                        execution,
                        adaptations,
                        performance: execution.performance,
                        processingTime: 500 + Math.random() * 600
                    };
                }
            },
            {
                id: 'analysis',
                name: 'Performance Analysis Mind',
                icon: '📊',
                description: 'Evaluates results and identifies improvements',
                baseEfficiency: 92,
                process: async (input, context) => {
                    const analysis = await analyzePerformance(input, context);
                    const improvements = await generateImprovements(analysis, context);
                    return {
                        analysis,
                        improvements,
                        metrics: analysis.metrics,
                        processingTime: 350 + Math.random() * 450
                    };
                }
            },
            {
                id: 'recursive_optimization',
                name: 'Recursive Optimization Mind',
                icon: '🔄',
                description: 'Continuously improves the entire pipeline',
                baseEfficiency: 95,
                process: async (input, context) => {
                    const optimization = await recursiveOptimization(input, context);
                    const pipelineImprovements = await improvePipeline(optimization, context);
                    return {
                        optimization,
                        pipelineImprovements,
                        efficiencyGain: pipelineImprovements.efficiencyGain,
                        processingTime: 600 + Math.random() * 700
                    };
                }
            }
        ];

        // Initialize demo
        function initializeDemo() {
            renderPipeline();
            updateMetrics();
            updateChart();
        }

        function renderPipeline() {
            const pipeline = document.getElementById('pipeline');
            pipeline.innerHTML = '';

            cognitiveMinds.forEach((mind, index) => {
                const step = document.createElement('div');
                step.className = 'mind-step';
                step.id = `step-${mind.id}`;
                
                step.innerHTML = `
                    <div class="mind-icon">${mind.icon}</div>
                    <div class="mind-content">
                        <div class="mind-name">${mind.name}</div>
                        <div class="mind-description">${mind.description}</div>
                        <div class="mind-output" id="output-${mind.id}"></div>
                        <div class="mind-metrics">
                            <div class="metric">
                                <div class="metric-value" id="efficiency-${mind.id}">${mind.baseEfficiency}%</div>
                                <div class="metric-label">Efficiency</div>
                            </div>
                            <div class="metric">
                                <div class="metric-value" id="time-${mind.id}">--</div>
                                <div class="metric-label">Time (ms)</div>
                            </div>
                            <div class="metric">
                                <div class="metric-value" id="improvements-${mind.id}">0</div>
                                <div class="metric-label">Improvements</div>
                            </div>
                        </div>
                    </div>
                `;
                
                pipeline.appendChild(step);
            });
        }

        function setTask(task) {
            document.getElementById('taskInput').value = task;
        }

        async function startProcessing() {
            if (isProcessing) return;
            
            const input = document.getElementById('taskInput').value.trim();
            if (!input) {
                alert('Please enter a task to process');
                return;
            }

            isProcessing = true;
            startTime = Date.now();
            improvementCycles = 0;
            
            updateStatus('inputStatus', 'processing', 'Processing');
            updateStatus('pipelineStatus', 'processing', 'Active');
            
            document.getElementById('executeBtn').disabled = true;
            document.getElementById('executeBtn').textContent = 'Processing...';
            
            addLogEntry('processing', 'Started cognitive processing pipeline');
            
            // Show recursive indicator
            document.getElementById('recursiveIndicator').classList.add('active');
            
            try {
                let context = { input, previousResults: [] };
                
                // Process through each mind
                for (let i = 0; i < cognitiveMinds.length; i++) {
                    const mind = cognitiveMinds[i];
                    await processMind(mind, context, i);
                    
                    // Trigger recursive improvement every 2-3 minds
                    if (i % 2 === 1 && i > 0) {
                        await triggerRecursiveImprovement(context, i);
                    }
                }
                
                // Final optimization cycle
                await triggerRecursiveImprovement(context, cognitiveMinds.length);
                
                // Complete processing
                completeProcessing();
                
            } catch (error) {
                console.error('Processing error:', error);
                addLogEntry('error', `Processing failed: ${error.message}`);
            }
        }

        async function processMind(mind, context, index) {
            const step = document.getElementById(`step-${mind.id}`);
            const output = document.getElementById(`output-${mind.id}`);
            const timeElement = document.getElementById(`time-${mind.id}`);
            
            // Activate mind
            step.classList.add('active');
            addLogEntry('processing', `${mind.name} activated`);
            
            // Simulate processing
            const result = await mind.process(context.input, context);
            
            // Update output with typing effect
            await typeText(output, formatOutput(mind, result));
            
            // Update metrics
            timeElement.textContent = Math.round(result.processingTime);
            
            // Mark as completed
            step.classList.remove('active');
            step.classList.add('completed');
            
            // Store result in context
            context.previousResults.push({ mind: mind.id, result });
            
            addLogEntry('complete', `${mind.name} completed in ${Math.round(result.processingTime)}ms`);
            
            updateMetrics();
        }

        async function triggerRecursiveImprovement(context, currentIndex) {
            improvementCycles++;
            
            addLogEntry('improvement', `Recursive improvement cycle ${improvementCycles} initiated`);
            
            // Show improvement indicators on relevant minds
            const mindsToImprove = Math.floor(Math.random() * 3) + 1;
            const improvements = [];
            
            for (let i = 0; i < mindsToImprove && i < currentIndex; i++) {
                const mindIndex = Math.floor(Math.random() * currentIndex);
                const mind = cognitiveMinds[mindIndex];
                const step = document.getElementById(`step-${mind.id}`);
                const efficiencyElement = document.getElementById(`efficiency-${mind.id}`);
                const improvementsElement = document.getElementById(`improvements-${mind.id}`);
                
                // Calculate improvement
                const currentEfficiency = parseInt(efficiencyElement.textContent);
                const improvement = Math.floor(Math.random() * 5) + 2;
                const newEfficiency = Math.min(100, currentEfficiency + improvement);
                
                // Update UI
                step.classList.add('improved');
                efficiencyElement.textContent = `${newEfficiency}%`;
                improvementsElement.textContent = parseInt(improvementsElement.textContent) + 1;
                
                improvements.push({ mind: mind.name, improvement });
                
                // Remove improvement indicator after animation
                setTimeout(() => {
                    step.classList.remove('improved');
                }, 2000);
            }
            
            // Update performance data
            const avgImprovement = improvements.reduce((sum, imp) => sum + imp.improvement, 0) / improvements.length || 0;
            const lastPerformance = performanceData[performanceData.length - 1];
            performanceData.push(Math.min(100, lastPerformance + avgImprovement));
            
            updateChart();
            updateMetrics();
            
            addLogEntry('improvement', `Improved ${improvements.length} minds by avg ${avgImprovement.toFixed(1)}%`);
            
            // Small delay for visual effect
            await new Promise(resolve => setTimeout(resolve, 1000));
        }

        function completeProcessing() {
            isProcessing = false;
            
            updateStatus('inputStatus', 'complete', 'Complete');
            updateStatus('pipelineStatus', 'complete', 'Complete');
            
            document.getElementById('executeBtn').disabled = false;
            document.getElementById('executeBtn').textContent = '🚀 Execute Recursive Processing';
            
            // Hide recursive indicator
            setTimeout(() => {
                document.getElementById('recursiveIndicator').classList.remove('active');
            }, 2000);
            
            const totalTime = Date.now() - startTime;
            addLogEntry('complete', `Pipeline completed in ${totalTime}ms with ${improvementCycles} improvement cycles`);
            
            updateMetrics();
        }

        function updateStatus(elementId, type, text) {
            const indicator = document.getElementById(elementId);
            const textElement = document.getElementById(elementId.replace('Status', 'StatusText'));
            
            indicator.className = `status-indicator ${type}`;
            textElement.textContent = text;
        }

        function updateMetrics() {
            const totalTime = isProcessing ? Date.now() - startTime : 0;
            const efficiencyGain = performanceData.length > 1 ? 
                performanceData[performanceData.length - 1] - performanceData[0] : 0;
            const accuracyScore = Math.min(100, 85 + efficiencyGain);
            
            document.getElementById('processingTime').textContent = `${totalTime}ms`;
            document.getElementById('improvementCycles').textContent = improvementCycles;
            document.getElementById('efficiencyGain').textContent = `${efficiencyGain.toFixed(1)}%`;
            document.getElementById('accuracyScore').textContent = `${accuracyScore.toFixed(1)}%`;
        }

        function updateChart() {
            const chart = document.getElementById('improvementChart');
            chart.innerHTML = '';
            
            const maxValue = Math.max(...performanceData);
            
            performanceData.forEach((value, index) => {
                const bar = document.createElement('div');
                bar.className = 'chart-bar';
                bar.style.height = `${(value / maxValue) * 160}px`;
                chart.appendChild(bar);
            });
        }

        function addLogEntry(type, message) {
            const logEntries = document.getElementById('logEntries');
            const entry = document.createElement('div');
            entry.className = 'log-entry';
            
            const time = new Date().toLocaleTimeString().slice(-8, -3);
            entry.innerHTML = `
                <div class="log-time">${time}</div>
                <div class="log-type ${type}">${type}</div>
                <div>${message}</div>
            `;
            
            logEntries.insertBefore(entry, logEntries.firstChild);
            
            // Keep only last 20 entries
            while (logEntries.children.length > 20) {
                logEntries.removeChild(logEntries.lastChild);
            }
        }

        async function typeText(element, text) {
            element.textContent = '';
            const speed = Math.max(10, Math.min(30, 1000 / text.length));
            
            for (let i = 0; i < text.length; i++) {
                element.textContent += text.charAt(i);
                await new Promise(resolve => setTimeout(resolve, speed));
            }
        }

        function resetDemo() {
            isProcessing = false;
            improvementCycles = 0;
            performanceData = [100];
            
            document.querySelectorAll('.mind-step').forEach(step => {
                step.classList.remove('active', 'completed', 'improved');
            });
            
            document.querySelectorAll('.mind-output').forEach(output => {
                output.textContent = '';
            });
            
            // Reset efficiency values
            cognitiveMinds.forEach(mind => {
                document.getElementById(`efficiency-${mind.id}`).textContent = `${mind.baseEfficiency}%`;
                document.getElementById(`time-${mind.id}`).textContent = '--';
                document.getElementById(`improvements-${mind.id}`).textContent = '0';
            });
            
            updateStatus('inputStatus', '', 'Ready');
            updateStatus('pipelineStatus', '', 'Idle');
            
            document.getElementById('executeBtn').disabled = false;
            document.getElementById('executeBtn').textContent = '🚀 Execute Recursive Processing';
            document.getElementById('taskInput').value = '';
            document.getElementById('recursiveIndicator').classList.remove('active');
            
            updateMetrics();
            updateChart();
            
            addLogEntry('complete', 'Demo reset - ready for new task');
        }

        function toggleAutoMode() {
            autoMode = !autoMode;
            const btn = document.getElementById('autoBtn');
            
            if (autoMode) {
                btn.textContent = 'Auto Mode: ON';
                btn.style.background = 'linear-gradient(135deg, var(--accent), var(--secondary))';
                startAutoMode();
            } else {
                btn.textContent = 'Auto Mode';
                btn.style.background = '';
                stopAutoMode();
            }
        }

        function startAutoMode() {
            const tasks = [
                'Develop a comprehensive AI strategy for a Fortune 500 company entering the healthcare market',
                'Design and implement a distributed microservices architecture for handling 10M+ daily transactions',
                'Create a machine learning pipeline for real-time fraud detection with 99.9% accuracy',
                'Optimize a React application with 50+ components for sub-second load times'
            ];
            
            let taskIndex = 0;
            
            const autoInterval = setInterval(() => {
                if (!autoMode) {
                    clearInterval(autoInterval);
                    return;
                }
                
                if (!isProcessing) {
                    setTask(tasks[taskIndex]);
                    setTimeout(() => {
                        startProcessing();
                    }, 1000);
                    taskIndex = (taskIndex + 1) % tasks.length;
                }
            }, 20000);
        }

        function stopAutoMode() {
            // Auto mode stopped - interval cleared by startAutoMode
        }

        // Helper functions for mind processing
        function calculateComplexity(input) {
            const factors = [
                input.length / 100,
                (input.match(/\b(architecture|system|design|implement|optimize|develop)\b/gi) || []).length,
                (input.match(/\b(million|billion|\d+M|\d+B)\b/gi) || []).length * 2
            ];
            return Math.min(100, factors.reduce((sum, factor) => sum + factor, 0) * 10);
        }

        function detectDomain(input) {
            const domains = {
                'healthcare': /health|medical|patient|clinical/gi,
                'finance': /financial|trading|payment|transaction|fraud/gi,
                'technology': /software|system|architecture|microservice|API/gi,
                'ai': /AI|machine learning|neural|model|algorithm/gi
            };
            
            for (const [domain, regex] of Object.entries(domains)) {
                if (regex.test(input)) return domain;
            }
            return 'general';
        }

        function extractRequirements(input) {
            const requirements = [];
            if (input.includes('real-time')) requirements.push('Real-time processing');
            if (input.includes('scalable') || input.includes('scale')) requirements.push('Scalability');
            if (input.includes('secure') || input.includes('security')) requirements.push('Security');
            if (input.includes('performance') || input.includes('fast')) requirements.push('High performance');
            return requirements.length > 0 ? requirements : ['Standard implementation'];
        }

        async function generateReflection(input, context) {
            const aspects = [
                'Task complexity analysis completed',
                'Identified key technical challenges',
                'Evaluated resource requirements',
                'Assessed risk factors and mitigation strategies'
            ];
            return aspects[Math.floor(Math.random() * aspects.length)];
        }

        function identifyOptimizations(context) {
            const optimizations = [
                'Parallel processing pathway identified',
                'Memory usage optimization available',
                'Algorithm efficiency improvement possible',
                'Resource allocation enhancement detected'
            ];
            return optimizations.slice(0, Math.floor(Math.random() * 3) + 1);
        }

        async function generateStrategy(input, context) {
            const complexity = context.previousResults[0]?.result.complexity || 50;
            const stepCount = Math.floor(complexity / 10) + 3;
            
            return {
                steps: Array(stepCount).fill(0).map((_, i) => `Strategic step ${i + 1}`),
                efficiency: 85 + Math.random() * 10,
                timeline: `${stepCount * 2} weeks estimated`
            };
        }

        async function optimizePlan(strategy, context) {
            return {
                ...strategy,
                efficiency: Math.min(100, strategy.efficiency + 5),
                optimizations: ['Parallelization applied', 'Resource optimization implemented']
            };
        }

        async function executeStrategy(input, context) {
            return {
                performance: 88 + Math.random() * 8,
                completionTime: Math.random() * 1000 + 500,
                qualityScore: 92 + Math.random() * 6
            };
        }

        async function adaptExecution(execution, context) {
            return {
                performanceGain: Math.random() * 5 + 2,
                adaptations: ['Real-time optimization applied', 'Performance tuning completed']
            };
        }

        async function analyzePerformance(input, context) {
            return {
                metrics: {
                    accuracy: 94 + Math.random() * 4,
                    efficiency: 89 + Math.random() * 8,
                    reliability: 96 + Math.random() * 3
                },
                recommendations: ['Continue current approach', 'Monitor performance metrics']
            };
        }

        async function generateImprovements(analysis, context) {
            return {
                efficiencyGain: Math.random() * 3 + 1,
                suggestions: ['Algorithm optimization', 'Resource reallocation', 'Caching strategy']
            };
        }

        async function recursiveOptimization(input, context) {
            return {
                pipelineEfficiency: 91 + Math.random() * 6,
                crossMindOptimizations: Math.floor(Math.random() * 3) + 1
            };
        }

        async function improvePipeline(optimization, context) {
            return {
                efficiencyGain: Math.random() * 4 + 2,
                systemImprovements: ['Pipeline optimization', 'Cross-mind coordination enhanced']
            };
        }

        function formatOutput(mind, result) {
            switch (mind.id) {
                case 'input_analysis':
                    return `Complexity: ${result.complexity.toFixed(1)}%\nDomain: ${result.domain}\nRequirements: ${result.requirements.join(', ')}`;
                case 'reflection':
                    return `${result.reflection}\nOptimizations: ${result.optimizations.join(', ')}\nSelf-improvements: ${result.selfImprovements}`;
                case 'planning':
                    return `Strategy: ${result.strategy.steps.length} steps planned\nEfficiency: ${result.strategy.efficiency.toFixed(1)}%\nTimeline: ${result.strategy.timeline}`;
                case 'execution':
                    return `Performance: ${result.execution.performance.toFixed(1)}%\nQuality: ${result.execution.qualityScore.toFixed(1)}%\nAdaptations: ${result.adaptations.performanceGain.toFixed(1)}% gain`;
                case 'analysis':
                    return `Accuracy: ${result.analysis.metrics.accuracy.toFixed(1)}%\nEfficiency: ${result.analysis.metrics.efficiency.toFixed(1)}%\nReliability: ${result.analysis.metrics.reliability.toFixed(1)}%`;
                case 'recursive_optimization':
                    return `Pipeline efficiency: ${result.optimization.pipelineEfficiency.toFixed(1)}%\nOptimizations: ${result.optimization.crossMindOptimizations}\nGain: ${result.pipelineImprovements.efficiencyGain.toFixed(1)}%`;
                default:
                    return 'Processing completed successfully';
            }
        }

        // Initialize demo on load
        document.addEventListener('DOMContentLoaded', initializeDemo);
    </script>
</body>
</html>